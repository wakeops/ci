name: Auto Tag

on:
  workflow_call:
    outputs:
      new_tag:
        description: "Tag created by this workflow"
        value: ${{ jobs.auto_tag.outputs.new_tag }}

permissions:
  contents: write

concurrency:
  group: tag-${{ github.repository }}
  cancel-in-progress: false

jobs:
  auto_tag:
    name: Auto Tag Repository
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # use full history to find previous tags

      - name: Determine next tag
        id: bump
        shell: bash
        run: |
          set -euo pipefail

          # Find last tag (or default)
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            last_tag=$(git describe --tags --abbrev=0)
            range="${last_tag}..HEAD"
          else
            last_tag="v0.0.0"
            range=""
          fi

          # Gather commit messages since last tag (subject + body, skips merges)
          if [ -n "$range" ]; then
            commits="$(git log "$range" --pretty=format:'%s%n%b' --no-merges)"
          else
            commits="$(git log --pretty=format:'%s%n%b' --no-merges)"
          fi

          # Decide bump level
          bump="patch"
          if echo "$commits" | grep -Eiq 'BREAKING CHANGE'; then
            bump="major"
          elif echo "$commits" | grep -Eq '^[^[:alnum:]]*[^[:alpha:]]*!:'; then
            # Handles "feat!: ..." / "fix!: ..." etc.
            bump="major"
          elif echo "$commits" | grep -Eiq '^[[:space:]]*feat(\(.+\))?:'; then
            bump="minor"
          elif echo "$commits" | grep -Eiq '^[[:space:]]*(fix|perf|refactor|build|chore|docs|test|ci)(\(.+\))?:'; then
            bump="patch"
          fi

          base="${last_tag#v}"
          IFS='.' read -r major minor patch <<< "$base"
          major=${major:-0}; minor=${minor:-0}; patch=${patch:-0}

          case "$bump" in
            major) major=$((major+1)); minor=0; patch=0 ;;
            minor) minor=$((minor+1)); patch=0 ;;
            patch) patch=$((patch+1)) ;;
          esac

          new_tag="v${major}.${minor}.${patch}"
          echo "Calculated bump: $bump  ->  $new_tag (from $last_tag)"
          echo "new_tag=$new_tag" >>"$GITHUB_OUTPUT"

      - name: Create and push tag
        shell: bash
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag -a "${{ steps.bump.outputs.new_tag }}" -m "Auto tag"
          git push origin "${{ steps.bump.outputs.new_tag }}" 
